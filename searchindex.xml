<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>如何「自动」捕获异常处理</title><url>/post/php-exception/</url><categories><category>php</category></categories><tags><tag>php</tag></tags><content type="html">
引入 大家都用过 try/catch ，它可以使代码更健壮，捕获错误后也可以触发一些上报机制，比如记日志，邮件提醒等。同时还能带来一些便利，比如使用 laravel 「事务处理」的时候，不用对每次的执行结果进行判断，直接在 catch 中回滚。
先看一段 PHP 原生代码：
$num = 0; try { echo 1 / $num; //除数为0 } catch (Exception $e) { echo 2; } 执行后发现，并没有进入到 catch 块，而是显示了错误信息： Warning: Division by zero in xxx 。
但是这段代码在大部分「框架」中都能进入到 catch 块，正常输出 2 。怎么做到的？ 错误类型 关于 PHP 的错误类型和相关说明，官方文档
有很详细的说明，主要报以下几种错：
Fatal Error ：致命错误；后面脚本终止运行；比如调用的函数不存在 Parse Error ：语法错误；后面脚本终止运行；比如少个分号 Warning Error ：警告错误；脚本不终止运行；比如除数为 0 Notice Error ：通知错误；脚本不终止运行；比如打印一个未定义的变量。 Notice Error 程度比 Warning Error 低 自动捕获异常原理 三个函数 实现自动捕获异常，主要是使用了 3 个关键的函数：
set_error_handler()
此函数可以用你自定义的方式来处理运行中的错误。当程序出现 部分类型 错误时，会 自动 调用你设置的方法：
&lt;?php set_error_handler(function(){ echo "捕获"; }); $num = 0; echo 1 / $num; //执行后,输出"捕获" 注意： set_error_handler 函数只能捕获系统产生的一些 Warning 、 Notice 级别的错误，对于其他类型是无能为力的。
trigger_error 函数 ：用户主动产生一个用户级别的 error/warning/notice 信息，这也能被捕获到：
&lt;?php set_error_handler(function(){ echo "捕获"; }); trigger_error("异常",E_USER_ERROR); //执行后,输出"捕获" 可以用 set_error_handler 注册多个错误处理函数，但是后注册的会 覆盖 前一个：
&lt;?php set_error_handler(function(){ echo "捕获"; }); set_error_handler(function(){ echo "捕获2"; }); $num = 0; echo 1 / $num; //执行后,输出"捕获2" register_shutdown_function()
注册一个会在 PHP 中止时执行的函数。多次调用 register_shutdown_function() ，这些被注册的回调会按照他们**「注册时的顺序被依次调用」：**
&lt;?php register_shutdown_function(function(){ echo "结束1"; }); register_shutdown_function(function(){ echo "结束2"; }); echo '开始';//执行后,输出"开始结束1结束2" set_exception_handler()
设置默认的异常处理程序，用于没有用 try/catch 块来捕获的异常。
&lt;?php set_exception_handler(function(){ echo '捕获'; }); throw new Exception("异常"); //抛出异常,没有手动捕获. //执行后,输出"捕获" 也可以注册多个，后注册的会 覆盖 前一个：
&lt;?php set_exception_handler(function(){ echo '捕获1'; }); set_exception_handler(function(){ echo '捕获2'; }); throw new Exception("异常");//执行后,输出"捕获2" 框架实现 了解了上述三个函数的作用，看看 laravel 是怎么联合使用上述函数，达到「自动捕获异常」目的。
一开始就在 app.php 中绑定了具体的异常处理类：
&lt;?php $app->singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class //具体的异常处理类 ); 接着，在 bootstrap 阶段的 Illuminate\Foundation\Bootstrap\HandleExceptions 部分中设置了系统异常处理行为并注册了全局的异常处理器：
&lt;?php class HandleExceptions { public function bootstrap(Application $app) { $this->app = $app; error_reporting(-1);//报告所有错误 //自定义错误处理函数，当遇到 Warning 、 Notice 级别的错误,自动调用 handleError set_error_handler([$this, 'handleError']); //当有未捕获的错误时,自动调用 handleException set_exception_handler([$this, 'handleException']); //当程序终止的时候,自动调用 handleShutdown register_shutdown_function([$this, 'handleShutdown']); } } 当遇到 Warning， Notice级别的错误，会自动调用 handleError 方法，由框架帮你抛出异常：
&lt;?php public function handleError($level, $message, $file = '', $line = 0, $context = []) { if (error_reporting() &amp; $level) { //抛出的异常,如果没有捕获,又会自动调用 handleException 方法,让 handleException 处理 throw new ErrorException($message, 0, $level, $file, $line); } } 当遇到 非 Warning， Notice级别的错误，导致程序终止，终止前会调用 handleShutdown 方法：
&lt;?php public function handleShutdown() { if (! is_null($error = error_get_last()) &amp;&amp; $this->isFatal($error['type'])) { //通过 error_get_last 获取最后发生的错误,接着把错误交给 handleException 处理 $this->handleException($this->fatalExceptionFromError($error, 0)); } } 最终，所有未捕获的异常都通过 handleException 集中处理：
&lt;?php public function handleException($e) { if (! $e instanceof Exception) { $e = new FatalThrowableError($e); } try { //上报错误,在这里记录日志,存到 storage/laravel.log 里 $this->getExceptionHandler()->report($e); } catch (Exception $e) { // } //响应异常 if ($this->app->runningInConsole()) { //渲染 CLI 请求的异常响应 $this->renderForConsole($e); } else { //渲染 HTTP 请求的异常响应 $this->renderHttpResponse($e); } } 稍微总结下：
通过 set_error_handler 设置了handleError 方法，当出现 Warning ， Notice 级别的错误会自动调用，在 handleError 中抛出异常。抛出的异常如果没有被捕获，会自动调用通过 set_exception_handler 设置的 handleException 方法，将异常交给它处理 当出现非 Warning， Notice 级别的错误，导致程序终止，会自动调用 register_shutdown_function 注册的 handleShutdown 方法，获取到最后发生的错误后，把错误交给 handleException 方法处理 handleException 方法集中处理异常。记录日志，响应请求等。 至此， laravel 实现了「自动」捕获异常。
注意：下面的代码我一直有个误区：当调用 A() 函数，因为 A 函数不存在，会出现致命错误，程序终止运行，接着调用 register_shutdown_function 注册的回调方法，里面抛出异常，然后会被 catch 捕获，输出333，其实这是不对的。因为发生致命错误，程序已经中断执行了，不会进入到 catch 块。
register_shutdown_function(function (){ throw new \Exception(333); }); try{ echo A(); }catch (\Exception $e){ echo $e->getMessage(); //不会进入到这里的 } 扩展下 《Modern PHP》提出了四个规则：
一定要让 PHP 报告错误； 在开发环境中要显示错误； 在生产环境中不能显示错误； 在开发环境和生产环境中都要记录错误； php.ini 文件推荐配置：
### 开发环境 display_errors = On display_startup_error = On error_reporting = -1 log_errors = On ### 生产环境 display_errors = Off display_startup_error = Off ; 报告 Notice 以外的所有错误 error_reporting = E_ALL &amp; ~E_NOTICE log_errors = On 参考 PHP官方文档
laravel内核分析</content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 91 年生人，天蝎男，坐标武汉。
2014 年本科毕业，专业计算机科学与技术，成为码仔算是专业对口。
2015 至今 都在写 php，2021 年结识 go 。
兴趣使然的码仔，记录平凡的生活。</content></entry></search>