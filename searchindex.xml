<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>mysql8 好用特性总结</title><url>/post/mysql8-%E7%89%B9%E6%80%A7/</url><categories><category>数据库</category></categories><tags><tag>mysql</tag></tags><content type="html"> 引入 MySQL 8 出来好几年了，但是没去了解，一直都在用 5.7 ，上次本杰问我知不知道「窗口函数」，直接老脸一红。
最近看了下相关资料，总结三个 MySQL 8 好用的新特性。
在某个平行时空，H5 尾牙的中奖信息如下：
隐藏索引 MySQL 8 可以临时隐藏索引。
隐藏索引可以在不改变实际索引结构的情况下，测试删除索引对于查询性能的影响，对于大表的优化十分有用，因为大表删除并重建索引的开销很大。
首先给上表的 money 字段加索引，然后隐藏索引，展示索引，结果如下：
窗口函数 我们要根据上表，统计如下信息，并展示在一张表里：
中奖总额 各岗位线中奖总额 每个人中奖金额，占岗位线金额的百分比 每个人中奖金额，占总金额百分比 在 MySQL 8 以前，我可能会选择用临时表完成此查询：
查总金额 根据岗位线聚合，查中奖总额 通过关联临时表，完成查询 MySQL 8 提供了 窗口函数，可以很方便的完成查询：
由上可知，窗口函数的作用，也是对数据进行分组。和group by不同的是，group by会把分组的结果聚合成一条记录，而窗口函数是将结果置于 每一条 数据记录中。 公用表表达式 公用表表达式是一个命名的临时结果集。它存在于单个查询语句中，主要作用就是可以 代替子查询，并且可以被后面的查询多次引用。
依据语法结构和执行方式的不同，可以分为 2 类：普通公用表表达式 和 递归公用表表达式。 普通公用表表达式 这里还有一张表，记录了历年的中奖记录，如下：
现在要查询「2020年和2021年都中奖的人」，可以用子查询查出结果，如下：
在 MySQL 8 中可以通过普通公用表表达式查询：
递归公用表表达式 这里有几只数码宝贝的进化链，
滚球兽->亚古兽->暴龙兽 独角兽->加布兽->加鲁鲁兽 年糕兽->甲虫兽->比多兽 存表如下：
现在要查成熟期的数码宝贝：</content></entry><entry><title>https 加密传输</title><url>/post/https-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/</url><categories><category>网络协议</category></categories><tags><tag>https</tag></tags><content type="html"> 为什么需要加密 http 的内容是明文传输，明文数据会经过中间代理服务器、路由器、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是 中间人攻击。
加密方式 常见的两种加密方式：
对称加密： 只有一个密钥，加密和解密都使用此密钥 非对称加密： 有一对公私钥，公钥加密的信息，只有私钥才能解密，私钥加密的信息，只有公钥才能解密 两者对比： 对称加密效率更高；非对称加密的安全性更高。
HTTPS 如何加密传输 https 是建构在 SSL/TLS 之上的 http 协议，它的数据都是加密传输，它是怎么实现的？为什么要这样实现？ 只用对称加密 如果只使用对称加密，那么客户端和服务端需要约定好密钥，加密解密都使用此密钥。但是产生的问题是：此密钥怎么让传输的双方知晓，同时不被别人知道。一旦密钥在传输过程中被劫持，数据无异于裸奔。
显然，只使用对称加密是不安全的。
只使用非对称加密 服务端生成一对公私钥。
客户端从服务端拿到公钥，用公钥加密数据传给服务端，服务端用私钥解密得到明文数据。
服务端处理完请求后，将返回数据用私钥加密传给客户端，客户端拿到数据用公钥解密。
这个方案也是不成熟的：
公钥明文在网络传输，如果被坏人劫持，那么服务端传输给客户端的数据可以被解密。 坏人也可以伪造客户端数据，公钥加密后传给服务端。 非对称加密比较耗时，加密的数据越大，耗时越久。 对称+非对称 结合上面 2 次失败的尝试，我们可以获取如下经验：
考虑到效率，传输数据用 对称加密 对称加密 的 密钥 不能暴露，使用 非对称加密 的方式保护它 流程如下：
这个方案其实还是有漏洞，会被 中间人攻击：
客户端和服务器在无感知的情况下继续通信，而中间人在暗中观察。这个漏洞的症结在于：客户端无法确认自己接收到的公钥来自于服务端。
那么怎么保证公钥的安全性？答案是 CA机构 颁发的 证书(Certificate) 。 HTTPS 加密 网站在使用 https 前，需要向 CA机构 申领一份 数字证书，数字证书里含有如下信息：
证书里面有服务端的公钥，只要保证证书的正确性，公钥就是正确的。
证书生成： 证书检测： 注意：浏览器和操作系统会预装各种 根证书，然后通过 数字证书链 层层解密，拿到 CA 机构 的公钥，所以能够解密 CA 机构 用私钥加密的 数字签名。
下面就是 HTTPS 加密流程（为了简单，做了适当删减），在 TCP 三次握手之后，开始 SSL 握手： 一些问题 ssl 握手 这么耗时， https 的每次请求都得走这个握手流程吗？ 客户端和服务端完成 ssl 握手 之后，服务端通过一个 只有自己知道的密钥 ticket key 将本次的 会话状态 加密后生成一个 ticket ，然后发送给客户端，客户端保存此 ticket 。
下次再建立 ssl 连接 时，可以将 ticket 发送给服务端，服务端解开 ticket 后，拿出里面的 会话状态，会话状态里包含了秘钥，然后开始用此秘钥加解密。
https 是加密传输的，那 Fiddler 等一些抓包工具是怎么抓 https 包 的？ 通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动设置代理，把代理证书安装到客户端中，然后客户端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回客户端。
需要注意的是： HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户已经对风险知情。
还有什么提高安全性的操作？
在 https 传输之前就对参数和值进行加密，可以增加爬虫成本。比如知乎的登录。 做好客户端的防反编译加固，防止本地算法被破解。 服务器的加密协议支持列表上去掉一些旧版本的 SSL/TLS协议 ，防止 HTTPS协议降级攻击。 根证书是 CA 机构 公钥安全的保障，根证书预装在操作系统中，所以不要安装盗版系统，同时也不要安装来不不明的证书。 免费证书安全吗？
因为 数字证书链 的存在，免费是证书也是有靠谱的 CA 机构 背书，安全性 理论上 没问题。
但是，因为免费 SSL证书 申请容易，审核宽松，很多赌博、钓鱼、欺诈网站都有使用。
同时，免费的 SSL证书 随时可能被停用。
所以，这钱还是不能省。 参考 极客时间《趣谈网络协议15讲》- 刘超 HTTPS 协议降级攻击
数字证书链</content></entry><entry><title>php 执行时间</title><url>/post/php-exec-time/</url><categories><category>php</category></categories><tags><tag>php</tag></tags><content type="html">
引入 接口一般都有「超时时间」。在LNMP环境中，打开nginx.conf，php.ini，php-fpm.conf，发现里面一堆和时间相关的配置项，哪些会影响到超时呢？实践出真知，决定对这些配置项做一些简单测试。
准备工作：
php:7.4-fpm nginx:1.21.1 起 2 个容器后，对配置项稍微做了一点修改，使之满足接下来的测试。 测试过程 测试一 我们知道php.ini文件有个控制脚本最大执行时间的配置：
max_execution_time = 30 index.php：
sleep(20); echo 1; 用浏览器访问，大约执行了 10s 的时候，请求502 Bad Gateway。php.ini文件明明设置了 30s，为什么还是会超时？
查看php-fpm日志：
以上信息告诉我们：
一个worker进程在执行时间超过 10s 后，收到一个signal 15被终止 fork了一个新的worker进程，进程id为 9 看来php-fpm.conf里也有个配置项影响着超时时间：
这个配置是为了防止某些情况下脚本不能终止，而采取的一个粗暴手段：直接kill掉进程，再fork一个新的。
所以，php-fpm.conf的request_terminate_timeout配置也影响着脚本的执行时间。 测试二 设置php-fpm.conf：
request_terminate_timeout = 30 设置php.ini：
max_execution_time = 1 index.php：
sleep(10); echo 1; 再次从浏览器请求index.php，心理预期是在 1s 的时候请求会超时，结果却请求成功。
为什么max_execution_time没有起到控制的作用？查阅官方文档有了答案：
「最大执行时间不会影响系统调用和系统操作」，也就是说 sleep()，system() 流操作，数据库操作 等，所耗费的时间不包含其中。以前给运营同事导数据时，有时担心sql语句执行太久而超时，会在接口开头搞一个set_time_limit(0)，现在看来应该没啥用。
再次调整index.php，不再用sleep：
timeConsumingTask(); //耗时任务 echo 1; 执行后php返回致命错误，查看php错误日志：
证明超时时间确实受php.ini的max_execution_time控制。
同时，看文档的时候还发现一个细节：
测试三 我们使用的web服务器一般是nginx，所以超时时间也受nginx影响。nginx有很多关于时间的配置项，这里只测试一个和php脚本执行时间相关的参数：fastcgi_read_timeout ，这个配置项指定nginx接受fastcgi响应的超时时间。
验证如下：
设置php-fpm.conf：
request_terminate_timeout = 30 设置php.ini：
max_execution_time = 30 设置nginx.conf：
location ~ \.php$ { fastcgi_read_timeout 1; //设置 1s ... } index.php：
sleep(10); echo 1; 在浏览器上请求后，返回：504 Gateway Time-out，nginx错误日志：
测试四 php-fpm模式的高并发场景下，worker进程不够用，会导致其他请求挂起，挂起的时间也和fastcgi_read_timeout有关。当超过这个时间，也会导致请求超时。
设置php-fpm.conf：
; 设置 worker 进程恒为 1 pm = static pm.max_children = 1 request_terminate_timeout = 30 index.php：
sleep(20); echo 1; ab测试：
ab -c 4 -n 16 http://127.0.0.1:80/index.php 看nginx的访问日志，有大量的超时请求：
感悟 每个环节都有自己的超时时间配置，比如客户端和nginx，proxy转发模块，nginx和php-fpm，数据库连接等，了解相关的配置项才能让我们在处理问题时精准定位。 多阅读官方文档，会发现一些忽视的细节。 参考 set_time_limit
fastcgi_read_timeout
nginx超时时间</content></entry><entry><title>laravel 如何自动发现包</title><url>/post/php-composer-auto-find/</url><categories><category>php</category></categories><tags><tag>php</tag><tag>composer</tag></tags><content type="html">
引入 laravel 在 5.5 版本以前，服务提供者通过配置文件config/app.php手动注册：
'providers' => [ Intervention\Image\ImageServiceProvider::class, ], laravel >= 5.5已增加包自动发现，这是如何做到的？基于laravel 8.5源码看看。 composer 事件 composer 定义了一系列事件，在特定条件触发，执行一些脚本。更多事件信息，👉传送门
laravel 原始composer.json文件摘录如下：
{ "scripts": { "post-autoload-dump": [ "Illuminate\\Foundation\\ComposerScripts::postAutoloadDump", "@php artisan package:discover --ansi" ], "post-update-cmd": [ "@php artisan vendor:publish --tag=laravel-assets --ansi" ], "post-root-package-install": [ "@php -r \"file_exists('.env') || copy('.env.example', '.env');\"" ], "post-create-project-cmd": [ "@php artisan key:generate --ansi" ] } } 这里只看post-autoload-dump事件，当执行composer install，composer update，composer require，composer dump-autoload时触发：
生成 packages.php 文件 laravel 触发post-autoload-dump事件时，执行 2 个脚本：
Illuminate\Foundation\ComposerScripts::postAutoloadDump 删除bootstrap/cache下的 3 个缓存文件
protected static function clearCompiled() { $laravel = new Application(getcwd()); //删 bootstrap/cache/config.php if (is_file($configPath = $laravel->getCachedConfigPath())) { @unlink($configPath); } //删 bootstrap/cache/services.php if (is_file($servicesPath = $laravel->getCachedServicesPath())) { @unlink($servicesPath); } //删 bootstrap/cache/packages.php if (is_file($packagesPath = $laravel->getCachedPackagesPath())) { @unlink($packagesPath); } } php artisan package:discover 追踪Illuminate\Foundation\Console\PackageDiscoverCommand：
public function handle(PackageManifest $manifest) { $manifest->build(); foreach (array_keys($manifest->manifest) as $package) { $this->line("Discovered Package: &lt;info>{$package}&lt;/info>"); } $this->info('Package manifest generated successfully.'); } 调用Illuminate\Foundation\PackageManifest类build方法，生成新的packages.php文件：
public function build() { $packages = []; //读 installed.json 文件，获取所有已安装完成的包 if ($this->files->exists($path = $this->vendorPath.'/composer/installed.json')) { $installed = json_decode($this->files->get($path), true); $packages = $installed['packages'] ?? $installed; } // 获取要剔除的包列表 $ignoreAll = in_array('*', $ignore = $this->packagesToIgnore()); //将所有需要发现的服务提供者写入 packages.php $this->write(collect($packages)->mapWithKeys(function ($package) { return [$this->format($package['name']) => $package['extra']['laravel'] ?? []]; })->each(function ($configuration) use (&amp;$ignore) { $ignore = array_merge($ignore, $configuration['dont-discover'] ?? []); })->reject(function ($configuration, $package) use ($ignore, $ignoreAll) { return $ignoreAll || in_array($package, $ignore); })->filter()->all()); } 注册服务提供者 从入口文件开始，追踪到Illuminate\Foundation\Application的bootstrapWith：
public function bootstrapWith(array $bootstrappers) { $this->hasBeenBootstrapped = true; //处理一些初始化工作，比如加载应用配置，注册异常处理，注册门面等，这里只关注 \Illuminate\Foundation\Bootstrap\RegisterProviders，注册服务提供者 foreach ($bootstrappers as $bootstrapper) { $this['events']->dispatch('bootstrapping: '.$bootstrapper, [$this]); //通过 make ,拿到 \Illuminate\Foundation\Bootstrap\RegisterProviders 对象，接着调用它的 bootstrap 方法 $this->make($bootstrapper)->bootstrap($this); $this['events']->dispatch('bootstrapped: '.$bootstrapper, [$this]); } } 追踪Illuminate\Foundation\Bootstrap\RegisterProviders：
public function bootstrap(Application $app) { $app->registerConfiguredProviders(); } 追踪Illuminate\Foundation\Application的registerConfiguredProviders，这里用上了前面生成的packages.php文件：
public function registerConfiguredProviders() { $providers = Collection::make($this->make('config')->get('app.providers')) ->partition(function ($provider) { return strpos($provider, 'Illuminate\\') === 0; }); //把 config/app.php 配置的服务提供者和 packages.php 里的服务提供者合并 $providers->splice(1, 0, [$this->make(PackageManifest::class)->providers()]); (new ProviderRepository($this, new Filesystem, $this->getCachedServicesPath())) ->load($providers->collapse()->toArray()); } 最后调用Illuminate\Foundation\ProviderRepository的load方法，再调用Illuminate\Foundation\Application的register，开始注册服务提供者，随时取用。
至此，实现包的自动发现。 总结 弄清 composer 事件的触发条件，可以利用此写一些上线部署脚本 自己写的包，如果想被 laravel 自动发现，可以在「包」的composer.json文件加： { "extra": { "laravel": { "providers": [ "Intervention\\Image\\ImageServiceProvider" ], "aliases": { "Image": "Intervention\\Image\\Facades\\Image" } } } } 通过源码可知，如果不想包自动发现，可以在 laravel 的composer.json文件里加： { "extra": { "laravel": { "dont-discover": [ "intervention/image" //不想要的包 ] } } }</content></entry><entry><title>如何「自动」捕获异常处理</title><url>/post/php-exception/</url><categories><category>php</category></categories><tags><tag>php</tag></tags><content type="html">
引入 大家都用过 try/catch ，它可以使代码更健壮，捕获错误后也可以触发一些上报机制，比如记日志，邮件提醒等。同时还能带来一些便利，比如使用 laravel 「事务处理」的时候，不用对每次的执行结果进行判断，直接在 catch 中回滚。
先看一段 PHP 原生代码：
$num = 0; try { echo 1 / $num; //除数为0 } catch (Exception $e) { echo 2; } 执行后发现，并没有进入到 catch 块，而是显示了错误信息： Warning: Division by zero in xxx 。
但是这段代码在大部分「框架」中都能进入到 catch 块，正常输出 2 。怎么做到的？ 错误类型 关于 PHP 的错误类型和相关说明，官方文档
有很详细的说明，主要报以下几种错：
Fatal Error ：致命错误；后面脚本终止运行；比如调用的函数不存在 Parse Error ：语法错误；后面脚本终止运行；比如少个分号 Warning Error ：警告错误；脚本不终止运行；比如除数为 0 Notice Error ：通知错误；脚本不终止运行；比如打印一个未定义的变量。 Notice Error 程度比 Warning Error 低 自动捕获异常原理 三个函数 实现自动捕获异常，主要是使用了 3 个关键的函数：
set_error_handler()
此函数可以用你自定义的方式来处理运行中的错误。当程序出现 部分类型 错误时，会 自动 调用你设置的方法：
&lt;?php set_error_handler(function(){ echo "捕获"; }); $num = 0; echo 1 / $num; //执行后,输出"捕获" 注意： set_error_handler 函数只能捕获系统产生的一些 Warning 、 Notice 级别的错误，对于其他类型是无能为力的。
trigger_error 函数 ：用户主动产生一个用户级别的 error/warning/notice 信息，这也能被捕获到：
&lt;?php set_error_handler(function(){ echo "捕获"; }); trigger_error("异常",E_USER_ERROR); //执行后,输出"捕获" 可以用 set_error_handler 注册多个错误处理函数，但是后注册的会 覆盖 前一个：
&lt;?php set_error_handler(function(){ echo "捕获"; }); set_error_handler(function(){ echo "捕获2"; }); $num = 0; echo 1 / $num; //执行后,输出"捕获2" register_shutdown_function()
注册一个会在 PHP 中止时执行的函数。多次调用 register_shutdown_function() ，这些被注册的回调会按照他们**「注册时的顺序被依次调用」：**
&lt;?php register_shutdown_function(function(){ echo "结束1"; }); register_shutdown_function(function(){ echo "结束2"; }); echo '开始';//执行后,输出"开始结束1结束2" set_exception_handler()
设置默认的异常处理程序，用于没有用 try/catch 块来捕获的异常。
&lt;?php set_exception_handler(function(){ echo '捕获'; }); throw new Exception("异常"); //抛出异常,没有手动捕获. //执行后,输出"捕获" 也可以注册多个，后注册的会 覆盖 前一个：
&lt;?php set_exception_handler(function(){ echo '捕获1'; }); set_exception_handler(function(){ echo '捕获2'; }); throw new Exception("异常");//执行后,输出"捕获2" 框架实现 了解了上述三个函数的作用，看看 laravel 是怎么联合使用上述函数，达到「自动捕获异常」目的。
一开始就在 app.php 中绑定了具体的异常处理类：
&lt;?php $app->singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class //具体的异常处理类 ); 接着，在 bootstrap 阶段的 Illuminate\Foundation\Bootstrap\HandleExceptions 部分中设置了系统异常处理行为并注册了全局的异常处理器：
&lt;?php class HandleExceptions { public function bootstrap(Application $app) { $this->app = $app; error_reporting(-1);//报告所有错误 //自定义错误处理函数，当遇到 Warning 、 Notice 级别的错误,自动调用 handleError set_error_handler([$this, 'handleError']); //当有未捕获的错误时,自动调用 handleException set_exception_handler([$this, 'handleException']); //当程序终止的时候,自动调用 handleShutdown register_shutdown_function([$this, 'handleShutdown']); } } 当遇到 Warning， Notice级别的错误，会自动调用 handleError 方法，由框架帮你抛出异常：
&lt;?php public function handleError($level, $message, $file = '', $line = 0, $context = []) { if (error_reporting() &amp; $level) { //抛出的异常,如果没有捕获,又会自动调用 handleException 方法,让 handleException 处理 throw new ErrorException($message, 0, $level, $file, $line); } } 当遇到 非 Warning， Notice级别的错误，导致程序终止，终止前会调用 handleShutdown 方法：
&lt;?php public function handleShutdown() { if (! is_null($error = error_get_last()) &amp;&amp; $this->isFatal($error['type'])) { //通过 error_get_last 获取最后发生的错误,接着把错误交给 handleException 处理 $this->handleException($this->fatalExceptionFromError($error, 0)); } } 最终，所有未捕获的异常都通过 handleException 集中处理：
&lt;?php public function handleException($e) { if (! $e instanceof Exception) { $e = new FatalThrowableError($e); } try { //上报错误,在这里记录日志,存到 storage/laravel.log 里 $this->getExceptionHandler()->report($e); } catch (Exception $e) { // } //响应异常 if ($this->app->runningInConsole()) { //渲染 CLI 请求的异常响应 $this->renderForConsole($e); } else { //渲染 HTTP 请求的异常响应 $this->renderHttpResponse($e); } } 稍微总结下：
通过 set_error_handler 设置了handleError 方法，当出现 Warning ， Notice 级别的错误会自动调用，在 handleError 中抛出异常。抛出的异常如果没有被捕获，会自动调用通过 set_exception_handler 设置的 handleException 方法，将异常交给它处理 当出现非 Warning， Notice 级别的错误，导致程序终止，会自动调用 register_shutdown_function 注册的 handleShutdown 方法，获取到最后发生的错误后，把错误交给 handleException 方法处理 handleException 方法集中处理异常。记录日志，响应请求等。 至此， laravel 实现了「自动」捕获异常。
注意：下面的代码我一直有个误区：当调用 A() 函数，因为 A 函数不存在，会出现致命错误，程序终止运行，接着调用 register_shutdown_function 注册的回调方法，里面抛出异常，然后会被 catch 捕获，输出333，其实这是不对的。因为发生致命错误，程序已经中断执行了，不会进入到 catch 块。
register_shutdown_function(function (){ throw new \Exception(333); }); try{ echo A(); }catch (\Exception $e){ echo $e->getMessage(); //不会进入到这里的 } 扩展下 《Modern PHP》提出了四个规则：
一定要让 PHP 报告错误； 在开发环境中要显示错误； 在生产环境中不能显示错误； 在开发环境和生产环境中都要记录错误； php.ini 文件推荐配置：
### 开发环境 display_errors = On display_startup_error = On error_reporting = -1 log_errors = On ### 生产环境 display_errors = Off display_startup_error = Off ; 报告 Notice 以外的所有错误 error_reporting = E_ALL &amp; ~E_NOTICE log_errors = On 参考 PHP官方文档
laravel内核分析</content></entry><entry><title>Markdown语法手册</title><url>/post/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 生活是什么？生活是柴米油盐的平淡；是行色匆匆早出晚归的奔波；生活是错的时间遇到对的人的遗憾；是爱的付出与回报；生活是看不同的风景，遇到不同的人；是行至水穷尽，坐看云起时的峰回路转；生活是灵魂经历伤痛后的微笑怒放；是挫折坎坷被晾晒后的坚强；生活是酸甜苦辣被岁月沉淀后的馨香；是经历风霜雪雨洗礼后的懂得；生活是走遍千山万水后，回眸一笑的洒脱。
有些事，猝不及防，不管你在不在乎；有些人，并非所想，不管你明不明白；有些路，必须得走，不管你愿不愿意。不怕事，不惹事，不避事，做好自己，用真心面对一切；少埋怨，少指责，少发火，学会沉静，用微笑考量一切；多体察，多包容，多思索，尽心尽力，虽缺憾但无悔。像蒲公英一样美丽，虽轻盈，但并不卑微，它有自己的生命，也有自己的世界！
引用 blockquote 元素表示从另一个来源引用的内容，可选的引用必须在 footer 或 cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 读懂自我，带着简单的心情，看复杂的人生，走坎坷的路！
注意： 可以在块引用中使用 Markdown 语法。
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 常规用法 SVG图像 Google Chrome
Firefox Browser
小图标 点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html>
&lt;html lang="en">
&lt;head>
&lt;meta charset="utf-8">
&lt;title>Example HTML5 Document&lt;/title>
&lt;/head>
&lt;body>
&lt;p>Test&lt;/p>
&lt;/body>
&lt;/html>
代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。</content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 91 年生人，天蝎男，坐标武汉。
2014 年本科毕业，专业计算机科学与技术，成为码仔算是专业对口。
2015 至今 都在写 php，2021 年结识 go 。
兴趣使然的码仔，记录平凡的生活。</content></entry></search>