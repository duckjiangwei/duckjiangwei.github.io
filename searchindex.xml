<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>laravel 如何自动发现包</title><url>/post/php-composer-auto-find/</url><categories><category>php</category></categories><tags><tag>php</tag><tag>composer</tag></tags><content type="html">
引入 laravel 在 5.5 版本以前，服务提供者通过配置文件config/app.php手动注册：
'providers' => [ Intervention\Image\ImageServiceProvider::class, ], laravel >= 5.5已增加包自动发现，这是如何做到的？基于laravel 8.5源码看看。 composer 事件 composer 定义了一系列事件，在特定条件触发，执行一些脚本。更多事件信息，👉传送门
laravel 原始composer.json文件摘录如下：
{ "scripts": { "post-autoload-dump": [ "Illuminate\\Foundation\\ComposerScripts::postAutoloadDump", "@php artisan package:discover --ansi" ], "post-update-cmd": [ "@php artisan vendor:publish --tag=laravel-assets --ansi" ], "post-root-package-install": [ "@php -r \"file_exists('.env') || copy('.env.example', '.env');\"" ], "post-create-project-cmd": [ "@php artisan key:generate --ansi" ] } } 这里只看post-autoload-dump事件，当执行composer install，composer update，composer require，composer dump-autoload时触发：
生成 packages.php 文件 laravel 触发post-autoload-dump事件时，执行 2 个脚本：
Illuminate\Foundation\ComposerScripts::postAutoloadDump 删除bootstrap/cache下的 3 个缓存文件
protected static function clearCompiled() { $laravel = new Application(getcwd()); //删 bootstrap/cache/config.php if (is_file($configPath = $laravel->getCachedConfigPath())) { @unlink($configPath); } //删 bootstrap/cache/services.php if (is_file($servicesPath = $laravel->getCachedServicesPath())) { @unlink($servicesPath); } //删 bootstrap/cache/packages.php if (is_file($packagesPath = $laravel->getCachedPackagesPath())) { @unlink($packagesPath); } } php artisan package:discover 追踪Illuminate\Foundation\Console\PackageDiscoverCommand：
public function handle(PackageManifest $manifest) { $manifest->build(); foreach (array_keys($manifest->manifest) as $package) { $this->line("Discovered Package: &lt;info>{$package}&lt;/info>"); } $this->info('Package manifest generated successfully.'); } 调用Illuminate\Foundation\PackageManifest类build方法，生成新的packages.php文件：
public function build() { $packages = []; //读 installed.json 文件，获取所有已安装完成的包 if ($this->files->exists($path = $this->vendorPath.'/composer/installed.json')) { $installed = json_decode($this->files->get($path), true); $packages = $installed['packages'] ?? $installed; } // 获取要剔除的包列表 $ignoreAll = in_array('*', $ignore = $this->packagesToIgnore()); //将所有需要发现的服务提供者写入 packages.php $this->write(collect($packages)->mapWithKeys(function ($package) { return [$this->format($package['name']) => $package['extra']['laravel'] ?? []]; })->each(function ($configuration) use (&amp;$ignore) { $ignore = array_merge($ignore, $configuration['dont-discover'] ?? []); })->reject(function ($configuration, $package) use ($ignore, $ignoreAll) { return $ignoreAll || in_array($package, $ignore); })->filter()->all()); } 注册服务提供者 从入口文件开始，追踪到Illuminate\Foundation\Application的bootstrapWith：
public function bootstrapWith(array $bootstrappers) { $this->hasBeenBootstrapped = true; //处理一些初始化工作，比如加载应用配置，注册异常处理，注册门面等，这里只关注 \Illuminate\Foundation\Bootstrap\RegisterProviders，注册服务提供者 foreach ($bootstrappers as $bootstrapper) { $this['events']->dispatch('bootstrapping: '.$bootstrapper, [$this]); //通过 make ,拿到 \Illuminate\Foundation\Bootstrap\RegisterProviders 对象，接着调用它的 bootstrap 方法 $this->make($bootstrapper)->bootstrap($this); $this['events']->dispatch('bootstrapped: '.$bootstrapper, [$this]); } } 追踪Illuminate\Foundation\Bootstrap\RegisterProviders：
public function bootstrap(Application $app) { $app->registerConfiguredProviders(); } 追踪Illuminate\Foundation\Application的registerConfiguredProviders，这里用上了前面生成的packages.php文件：
public function registerConfiguredProviders() { $providers = Collection::make($this->make('config')->get('app.providers')) ->partition(function ($provider) { return strpos($provider, 'Illuminate\\') === 0; }); //把 config/app.php 配置的服务提供者和 packages.php 里的服务提供者合并 $providers->splice(1, 0, [$this->make(PackageManifest::class)->providers()]); (new ProviderRepository($this, new Filesystem, $this->getCachedServicesPath())) ->load($providers->collapse()->toArray()); } 最后调用Illuminate\Foundation\ProviderRepository的load方法，再调用Illuminate\Foundation\Application的register，开始注册服务提供者，随时取用。
至此，实现包的自动发现。 总结 弄清 composer 事件的触发条件，可以利用此写一些上线部署脚本 自己写的包，如果想被 laravel 自动发现，可以在「包」的composer.json文件加： { "extra": { "laravel": { "providers": [ "Intervention\\Image\\ImageServiceProvider" ], "aliases": { "Image": "Intervention\\Image\\Facades\\Image" } } } } 通过源码可知，如果不想包自动发现，可以在 laravel 的composer.json文件里加： { "extra": { "laravel": { "dont-discover": [ "intervention/image" //不想要的包 ] } } }</content></entry><entry><title>如何「自动」捕获异常处理</title><url>/post/php-exception/</url><categories><category>php</category></categories><tags><tag>php</tag></tags><content type="html">
引入 大家都用过 try/catch ，它可以使代码更健壮，捕获错误后也可以触发一些上报机制，比如记日志，邮件提醒等。同时还能带来一些便利，比如使用 laravel 「事务处理」的时候，不用对每次的执行结果进行判断，直接在 catch 中回滚。
先看一段 PHP 原生代码：
$num = 0; try { echo 1 / $num; //除数为0 } catch (Exception $e) { echo 2; } 执行后发现，并没有进入到 catch 块，而是显示了错误信息： Warning: Division by zero in xxx 。
但是这段代码在大部分「框架」中都能进入到 catch 块，正常输出 2 。怎么做到的？ 错误类型 关于 PHP 的错误类型和相关说明，官方文档
有很详细的说明，主要报以下几种错：
Fatal Error ：致命错误；后面脚本终止运行；比如调用的函数不存在 Parse Error ：语法错误；后面脚本终止运行；比如少个分号 Warning Error ：警告错误；脚本不终止运行；比如除数为 0 Notice Error ：通知错误；脚本不终止运行；比如打印一个未定义的变量。 Notice Error 程度比 Warning Error 低 自动捕获异常原理 三个函数 实现自动捕获异常，主要是使用了 3 个关键的函数：
set_error_handler()
此函数可以用你自定义的方式来处理运行中的错误。当程序出现 部分类型 错误时，会 自动 调用你设置的方法：
&lt;?php set_error_handler(function(){ echo "捕获"; }); $num = 0; echo 1 / $num; //执行后,输出"捕获" 注意： set_error_handler 函数只能捕获系统产生的一些 Warning 、 Notice 级别的错误，对于其他类型是无能为力的。
trigger_error 函数 ：用户主动产生一个用户级别的 error/warning/notice 信息，这也能被捕获到：
&lt;?php set_error_handler(function(){ echo "捕获"; }); trigger_error("异常",E_USER_ERROR); //执行后,输出"捕获" 可以用 set_error_handler 注册多个错误处理函数，但是后注册的会 覆盖 前一个：
&lt;?php set_error_handler(function(){ echo "捕获"; }); set_error_handler(function(){ echo "捕获2"; }); $num = 0; echo 1 / $num; //执行后,输出"捕获2" register_shutdown_function()
注册一个会在 PHP 中止时执行的函数。多次调用 register_shutdown_function() ，这些被注册的回调会按照他们**「注册时的顺序被依次调用」：**
&lt;?php register_shutdown_function(function(){ echo "结束1"; }); register_shutdown_function(function(){ echo "结束2"; }); echo '开始';//执行后,输出"开始结束1结束2" set_exception_handler()
设置默认的异常处理程序，用于没有用 try/catch 块来捕获的异常。
&lt;?php set_exception_handler(function(){ echo '捕获'; }); throw new Exception("异常"); //抛出异常,没有手动捕获. //执行后,输出"捕获" 也可以注册多个，后注册的会 覆盖 前一个：
&lt;?php set_exception_handler(function(){ echo '捕获1'; }); set_exception_handler(function(){ echo '捕获2'; }); throw new Exception("异常");//执行后,输出"捕获2" 框架实现 了解了上述三个函数的作用，看看 laravel 是怎么联合使用上述函数，达到「自动捕获异常」目的。
一开始就在 app.php 中绑定了具体的异常处理类：
&lt;?php $app->singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class //具体的异常处理类 ); 接着，在 bootstrap 阶段的 Illuminate\Foundation\Bootstrap\HandleExceptions 部分中设置了系统异常处理行为并注册了全局的异常处理器：
&lt;?php class HandleExceptions { public function bootstrap(Application $app) { $this->app = $app; error_reporting(-1);//报告所有错误 //自定义错误处理函数，当遇到 Warning 、 Notice 级别的错误,自动调用 handleError set_error_handler([$this, 'handleError']); //当有未捕获的错误时,自动调用 handleException set_exception_handler([$this, 'handleException']); //当程序终止的时候,自动调用 handleShutdown register_shutdown_function([$this, 'handleShutdown']); } } 当遇到 Warning， Notice级别的错误，会自动调用 handleError 方法，由框架帮你抛出异常：
&lt;?php public function handleError($level, $message, $file = '', $line = 0, $context = []) { if (error_reporting() &amp; $level) { //抛出的异常,如果没有捕获,又会自动调用 handleException 方法,让 handleException 处理 throw new ErrorException($message, 0, $level, $file, $line); } } 当遇到 非 Warning， Notice级别的错误，导致程序终止，终止前会调用 handleShutdown 方法：
&lt;?php public function handleShutdown() { if (! is_null($error = error_get_last()) &amp;&amp; $this->isFatal($error['type'])) { //通过 error_get_last 获取最后发生的错误,接着把错误交给 handleException 处理 $this->handleException($this->fatalExceptionFromError($error, 0)); } } 最终，所有未捕获的异常都通过 handleException 集中处理：
&lt;?php public function handleException($e) { if (! $e instanceof Exception) { $e = new FatalThrowableError($e); } try { //上报错误,在这里记录日志,存到 storage/laravel.log 里 $this->getExceptionHandler()->report($e); } catch (Exception $e) { // } //响应异常 if ($this->app->runningInConsole()) { //渲染 CLI 请求的异常响应 $this->renderForConsole($e); } else { //渲染 HTTP 请求的异常响应 $this->renderHttpResponse($e); } } 稍微总结下：
通过 set_error_handler 设置了handleError 方法，当出现 Warning ， Notice 级别的错误会自动调用，在 handleError 中抛出异常。抛出的异常如果没有被捕获，会自动调用通过 set_exception_handler 设置的 handleException 方法，将异常交给它处理 当出现非 Warning， Notice 级别的错误，导致程序终止，会自动调用 register_shutdown_function 注册的 handleShutdown 方法，获取到最后发生的错误后，把错误交给 handleException 方法处理 handleException 方法集中处理异常。记录日志，响应请求等。 至此， laravel 实现了「自动」捕获异常。
注意：下面的代码我一直有个误区：当调用 A() 函数，因为 A 函数不存在，会出现致命错误，程序终止运行，接着调用 register_shutdown_function 注册的回调方法，里面抛出异常，然后会被 catch 捕获，输出333，其实这是不对的。因为发生致命错误，程序已经中断执行了，不会进入到 catch 块。
register_shutdown_function(function (){ throw new \Exception(333); }); try{ echo A(); }catch (\Exception $e){ echo $e->getMessage(); //不会进入到这里的 } 扩展下 《Modern PHP》提出了四个规则：
一定要让 PHP 报告错误； 在开发环境中要显示错误； 在生产环境中不能显示错误； 在开发环境和生产环境中都要记录错误； php.ini 文件推荐配置：
### 开发环境 display_errors = On display_startup_error = On error_reporting = -1 log_errors = On ### 生产环境 display_errors = Off display_startup_error = Off ; 报告 Notice 以外的所有错误 error_reporting = E_ALL &amp; ~E_NOTICE log_errors = On 参考 PHP官方文档
laravel内核分析</content></entry><entry><title>Markdown语法手册</title><url>/post/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 生活是什么？生活是柴米油盐的平淡；是行色匆匆早出晚归的奔波；生活是错的时间遇到对的人的遗憾；是爱的付出与回报；生活是看不同的风景，遇到不同的人；是行至水穷尽，坐看云起时的峰回路转；生活是灵魂经历伤痛后的微笑怒放；是挫折坎坷被晾晒后的坚强；生活是酸甜苦辣被岁月沉淀后的馨香；是经历风霜雪雨洗礼后的懂得；生活是走遍千山万水后，回眸一笑的洒脱。
有些事，猝不及防，不管你在不在乎；有些人，并非所想，不管你明不明白；有些路，必须得走，不管你愿不愿意。不怕事，不惹事，不避事，做好自己，用真心面对一切；少埋怨，少指责，少发火，学会沉静，用微笑考量一切；多体察，多包容，多思索，尽心尽力，虽缺憾但无悔。像蒲公英一样美丽，虽轻盈，但并不卑微，它有自己的生命，也有自己的世界！
引用 blockquote 元素表示从另一个来源引用的内容，可选的引用必须在 footer 或 cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 读懂自我，带着简单的心情，看复杂的人生，走坎坷的路！
注意： 可以在块引用中使用 Markdown 语法。
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 常规用法 SVG图像 Google Chrome
Firefox Browser
小图标 点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html>
&lt;html lang="en">
&lt;head>
&lt;meta charset="utf-8">
&lt;title>Example HTML5 Document&lt;/title>
&lt;/head>
&lt;body>
&lt;p>Test&lt;/p>
&lt;/body>
&lt;/html>
代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。</content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 91 年生人，天蝎男，坐标武汉。
2014 年本科毕业，专业计算机科学与技术，成为码仔算是专业对口。
2015 至今 都在写 php，2021 年结识 go 。
兴趣使然的码仔，记录平凡的生活。</content></entry></search>